function wrap(name)
	for k,v in pairs(rs.getNames()) do
		if peripheral.getType(v)==name then
			return peripheral.wrap(v)
		end
	end
end

function savePrefs(name,data,tf) -- saves data to a file
	local file=io.open(name,"w")
	if tf then
		file:write(data)
	else
		file:write(serialize(data))
	end
	file:close()
end

function readPrefs(name,tf) -- reads data from a file
	local file=fs.open(name,"r")
	if not file then return false end
	local dat
	if tf then
		dat=file.readAll()
	else
		dat=unserialize(file.readAll())
	end
	file.close()
	return dat
end
function rlen(tbl)
	local cnt=0
	for k,v in pairs(tbl) do
		cnt=cnt+1
	end
	return cnt
end

-- base converter
-- usage:
-- bcv(number,charlist,returnTable?)
function bcv(N,C,TF)
	if not C then
		return string.format("%X",N) -- default to hex
	end
	local Str=""
	local Tbl={}
    repeat
        local D=(N%(#C))+1
        N=math.floor(N/(#C))
		Str=string.sub(C,D,D)..Str
		table.insert(Tbl,1,D)
    until N==0
	if TF then
		return Tbl
	end
	return Str
end
function serializeImpl(t,TF) -- converts anything into a string
	local sType = type(t)
	if sType == "table" then
		local result = "{"
		local aset=1
		local comma=false
		for k,v in pairs(t) do
			comma=true
			if k==aset then
				result = result..serializeImpl(v,TF)..","
				aset=aset+1
			else
				local tmp=serializeImpl(k,TF)
				local tmp2=serializeImpl(v,TF)
				if type(k)=="string" then
					local r=loadstring("return {"..k.."="..(TF and "true" or tmp2).."}")
					if r and not string.find(k,",") then
						result=result..k.."="..tmp2..","
					else
						result=result.."["..tmp.."]="..tmp2..","
					end
				else
					result=result.."["..tmp.."]="..tmp2..","
				end
			end
		end
		if comma then
			result=string.sub(result,1,-2)
		end
		result = result.."}"
		return result
	elseif sType == "string" then
		return string.gsub(string.format("%q",t),"\\\n","\\n") -- improved from textutils
	elseif sType == "number" or sType == "boolean" or sType == "nil" then
		return tostring(t)
	elseif sType == "function" and not TF then -- function i added
		local status,data=pcall(string.dump,t) -- convert the function into a string
		if status then
			return 'func('..string.format("%q",data)..')' -- format it so it dosent screw up syntax
		else
			error()
		end
	elseif sType == "function" and TF then
		return tostring(t)
	else
		error()
	end
end
 
function split(T,func) -- splits a table
	if func then
		T=func(T) -- advanced function
	end
	local Out={}
	if type(T)=="table" then
		for k,v in pairs(T) do
			Out[split(k)]=split(v) -- set the values for the new table
		end
	else
		Out=T
	end
	return Out
end
function serialize(t,TF) -- TODO: combine with serializeImpl 
	t=split(t)
	return serializeImpl(t,TF)
end
 
function unserialize(s,tf) -- converts a string back into its original form
	if type(s)~="string" then
		error("String exepcted. got "..type(s),2)
	end
	local func, e = loadstring( "return "..s, "serialize" )
	local funcs={} -- a table to store all the functions generated by f() (for securety)
	if not func then
		error("Invalid string.")
	end
	setfenv( func, { -- make sure nothing can be called within the function
		func=function(S) -- puts function requests into the funcs table
			local new={}
			funcs[new]=S 
			return new
		end,
	})
	return split(func(),function(val) -- apply functions if any
		if funcs[val] then
			return loadstring(funcs[val])
		else
			return val
		end
	end)
end

function zfill(N) -- ensures a hax number has 2 digits
	N=bcv(N)
	Zs=""
	if #N==1 then
		Zs="0"
	end
	return Zs..N
end

function sure(N,n) -- make sure there is no errors when decoding a hex stream
	if (l2-n)<1 then N="0" end
	return N
end

function hexToStr(S) -- converts a hex stream back into a character
	Out=""
	for l1=1,#S,2 do
		l2=(#S-l1)+1
		CNum=tonumber("0x"..sure(string.sub(S,l2-1,l2-1),1) .. sure(string.sub(S,l2,l2),0))
		Out=string.char(CNum)..Out
	end
	return Out
end

function strToHex(S) -- converts a string into a hex stream (most usefull when you dont want a string to screw up formatting)
	local O=""
	for char in string.gmatch(S,".") do
		O=O..zfill(string.byte(char))
	end
	return O
end

function compress( ... ) -- serializes all of its arguments into a table and catches errors
	local E,D=pcall(infutil.serialize,{...}) 
	if E then
		return string.sub(D,2,-2)
	else
		return false
	end
end

function decompress(S) -- convert a serialized table into a normal one and catches errors
	if not S then
		return false
	end
	local E,D,C=pcall(unserialize,"{"..S.."}")
	if C or not E then
		return false
	else
		return type(D)=="table" and D
	end
end

function rev(T) -- reverses a tables indexes
	local oT={}
	for k,v in pairs(T) do
		oT[(#T-k)+1]=v
	end
	return oT
end

function receive(ID,nTimeout) -- receive a message from a specific id
	local timer = nil
	if nTimeout then
		timer = os.startTimer( nTimeout )
	end
	while true do
		local e, p1, p2, p3 = os.pullEvent()
		if e == "rednet_message" and p1 == ID then
			return p2
		elseif e == "timer" and p1 == timer then
			return
		end
	end
end